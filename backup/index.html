<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta property="og:image" content="https://jojkos.github.io/vibeGames/factorioLampEditor/assets/example.png" />
    <title>Factorio Lamp Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/pako@2.0.4/dist/pako.min.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #0d0e12;
        color: #d1d5db;
        min-height: 100vh;
        overflow-x: hidden;
        overscroll-behavior: none;
      }

      /* --- CUSTOM SCROLLBARS --- */
      ::-webkit-scrollbar {
        width: 8px;
        height: 8px;
      }
      ::-webkit-scrollbar-thumb {
        background-color: #4b5563;
        border-radius: 4px;
      }
      ::-webkit-scrollbar-track {
        background-color: #1f2937;
      }

      .canvas-container {
        background-image: linear-gradient(45deg, #1f2937 25%, transparent 25%),
          linear-gradient(-45deg, #1f2937 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, #1f2937 75%),
          linear-gradient(-45deg, transparent 75%, #1f2937 75%);
        background-size: 20px 20px;
        background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        box-shadow: inset 0 0 20px rgba(0, 0, 0, 0.5);
        cursor: crosshair;
        touch-action: none;
      }

      /* Base styles for buttons that used to use @apply */
      .mode-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 0.75rem 1.5rem;
        border-radius: 0.75rem;
        border-width: 2px;
        font-weight: 700;
        font-size: 0.875rem;
        text-transform: uppercase;
        letter-spacing: 0.05em;
        transition: all 0.2s;
      }

      .tool-btn {
        padding: 0.5rem;
        border-radius: 0.25rem;
        background-color: #374151; /* bg-gray-700 */
        color: #d1d5db; /* text-gray-300 */
        border: 1px solid #4b5563; /* border-gray-600 */
        transition: all 0.15s;
      }
      .tool-btn:hover {
        background-color: #4b5563; /* hover:bg-gray-600 */
      }
      .tool-btn.active {
        background-color: #d97706; /* bg-yellow-600 */
        color: white;
        border-color: #f59e0b; /* border-yellow-500 */
        transform: translateY(-2px);
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
      }

      input[type="color"] {
        -webkit-appearance: none;
        appearance: none;
        border: none;
        padding: 0;
        width: 100%;
        height: 100%;
        cursor: pointer;
        background: none;
      }
      input[type="color"]::-webkit-color-swatch-wrapper {
        padding: 0;
      }
      input[type="color"]::-webkit-color-swatch {
        border: none;
        border-radius: 4px;
      }

      .coffee-link {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        background-color: #FFDD00;
        color: #000;
        font-weight: 600;
        padding: 0.5rem 1rem;
        border-radius: 0.5rem;
        text-decoration: none;
        font-size: 0.875rem;
        transition: transform 0.2s, box-shadow 0.2s;
        box-shadow: 0 4px 6px rgba(0,0,0,0.2);
      }
      .coffee-link:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 8px rgba(0,0,0,0.25);
      }
    </style>
  </head>
  <body class="flex flex-col h-screen">
    <!-- Header & Tabs -->
    <header
      class="bg-gray-900 border-b border-gray-700 shadow-xl z-20 shrink-0"
    >
      <div
        class="flex items-center justify-between px-4 py-3 h-16"
      >
        <!-- Logo Section -->
        <div class="flex items-center gap-3">
          <div
            class="bg-yellow-500/10 p-2 rounded-xl border border-yellow-500/20 shrink-0"
          >
            <i class="fa-solid fa-lightbulb text-yellow-500 text-xl"></i>
          </div>
          <div>
            <h1
              class="text-lg font-extrabold text-gray-100 leading-tight tracking-tight"
            >
              Factorio Lamp Editor
            </h1>
            <p
              class="text-[10px] text-gray-500 font-mono uppercase tracking-widest hidden sm:block"
            >
              Blueprint Generator
            </p>
          </div>
        </div>

        <button
          onclick="toggleHelp()"
          class="coffee-link bg-indigo-600 hover:bg-indigo-500 text-white border-transparent"
          style="right: 200px; background-color: #4f46e5; color: white;"
        >
          <i class="fa-solid fa-circle-question text-lg"></i>
          <span class="hidden sm:inline">Help</span>
        </button>

        <!-- Buy Me a Coffee -->
        <a
          href="https://buymeacoffee.com/jojkos"
          target="_blank"
          rel="noopener noreferrer"
          class="coffee-link"
        >
          <span style="font-size: 1.2rem">â˜•</span>
          <span class="hidden sm:inline">Buy Me a Coffee</span>
        </a>
      </div>
    </header>
    <!-- CONTENT AREA -->
    <main class="flex-1 overflow-hidden relative w-full flex flex-col md:flex-row">
      <!-- REMOVED TEXT GEN VIEW -->

      <!-- VIEW 2: DRAWING STUDIO (Canvas Mode) -->
      <div
        id="view-draw"
        class="absolute inset-0 flex flex-col md:flex-row w-full h-full"
      >        <!-- Main Canvas Area (Top on Mobile, Right on Desktop) -->
        <main
          class="flex-1 flex flex-col relative bg-gray-950 order-1 md:order-2 h-[60vh] md:h-auto overflow-hidden"
        >
          <div class="absolute top-4 right-4 z-10">
            <button
              onclick="generateDrawBlueprint()"
              class="px-4 py-2 bg-yellow-600 hover:bg-yellow-500 text-white font-bold rounded-lg shadow-lg text-xs md:text-sm flex items-center gap-2 transition-transform hover:-translate-y-0.5 active:scale-95 border border-yellow-400/20 backdrop-blur-sm opacity-90 hover:opacity-100"
            >
              <i class="fa-solid fa-clipboard-check"></i>
              <span class="hidden sm:inline">Copy Blueprint</span>
            </button>
          </div>

          <div
            id="stamp-hint"
            class="absolute top-4 left-4 z-10 bg-blue-600/90 backdrop-blur text-white px-3 py-1.5 rounded-lg shadow-lg text-[10px] md:text-xs font-bold hidden border border-blue-400/30 flex items-center gap-2 pointer-events-none"
          >
            <i class="fa-solid fa-crosshairs animate-pulse"></i>
            <span>Click to Stamp</span>
          </div>

          <div
            id="viewport"
            class="flex-1 relative overflow-hidden w-full bg-[#0d0e12] touch-none"
          >
            <canvas
              id="gridCanvas"
              class="block w-full h-full outline-none"
              draggable="false"
              oncontextmenu="return false;"
            ></canvas>
          </div>


          <div
            class="h-6 md:h-8 bg-gray-900 border-t border-gray-800 flex items-center px-4 md:px-6 text-[10px] text-gray-500 justify-between shrink-0 font-mono"
          >
            <span id="coords" class="opacity-70">X: 0 Y: 0</span>
            <span id="canvas-status" class="font-bold opacity-70"></span>
          </div>        </main>

        <!-- Toolbar Sidebar (Bottom on Mobile, Left on Desktop) -->
        <aside
          class="w-full md:w-72 bg-gray-800 border-t md:border-t-0 md:border-r border-gray-700 flex flex-col shrink-0 overflow-y-auto shadow-2xl z-10 order-2 md:order-1 max-h-[40vh] md:max-h-full"
        >
          <div class="p-4 md:p-6 border-b border-gray-700">
            <div class="flex justify-between items-center mb-2 md:mb-4">
              <h3
                class="text-[10px] md:text-xs font-bold text-gray-500 uppercase tracking-wider"
              >
                Drawing Tools
              </h3>
              <div class="flex items-center gap-2">
                 <!-- Color Picker -->
                 <div class="h-6 w-6 relative rounded overflow-hidden border border-gray-600 shadow-sm group hover:border-gray-500 transition-colors">
                    <input type="color" id="draw-color" value="#ffffff" class="absolute inset-0 p-0 m-0 border-0 outline-none cursor-pointer" title="Choose Color">
                 </div>
                 <div class="flex gap-1">
                <button
                  class="tool-btn text-xs py-1 px-2"
                  onclick="undo()"
                  title="Undo"
                >
                  <i class="fa-solid fa-rotate-left"></i>
                </button>
                <button
                  class="tool-btn text-xs py-1 px-2"
                  onclick="redo()"
                  title="Redo"
                >
                  <i class="fa-solid fa-rotate-right"></i>
                </button>
              </div>
            </div>
          </div>

            <div class="grid grid-cols-5 gap-2 md:gap-3">
              <button
                class="tool-btn aspect-square flex items-center justify-center text-lg"
                id="btn-pan"
                onclick="setDrawTool('pan')"
                title="Pan Tool (H)"
              >
                <i class="fa-solid fa-hand"></i>
              </button>
              <button
                class="tool-btn active aspect-square flex items-center justify-center text-lg"
                id="btn-brush"
                onclick="setDrawTool('brush')"
                title="Brush (B)"
              >
                <i class="fa-solid fa-pencil"></i>
              </button>
              <button
                class="tool-btn aspect-square flex items-center justify-center text-lg"
                id="btn-fill"
                onclick="setDrawTool('fill')"
                title="Fill (F)"
              >
                <i class="fa-solid fa-fill-drip"></i>
              </button>
              <button
                class="tool-btn aspect-square flex items-center justify-center text-lg"
                id="btn-erase"
                onclick="setDrawTool('erase')"
                title="Eraser (E)"
              >
                <i class="fa-solid fa-eraser"></i>
              </button>
            </div>
          </div>
          
          <div class="p-4 md:p-6 border-b border-gray-700">
             <h3
              class="text-[10px] md:text-xs font-bold text-gray-500 uppercase tracking-wider mb-2 md:mb-4"
            >
              Stamps
            </h3>
            <div class="mb-3 md:mb-5">
              <div class="flex gap-2">
                <input
                  type="text"
                  id="draw-text-input"
                  placeholder="Text"
                  class="flex-1 bg-gray-900 border border-gray-600 rounded px-3 py-1.5 text-xs font-mono text-yellow-500 focus:border-yellow-500 outline-none transition-colors"
                  onkeydown="if(event.key === 'Enter') activateTextStamp()"
                />
                <button
                  class="bg-gray-700 hover:bg-gray-600 border border-gray-600 text-gray-200 px-3 py-1.5 rounded text-[10px] font-bold uppercase tracking-wider transition-colors"
                  onclick="activateTextStamp()"
                >
                  Text
                </button>
              </div>
            </div>

            <div class="mb-2">
              <label
                id="upload-btn"
                class="flex items-center justify-center w-full h-10 px-4 transition bg-gray-700 hover:bg-gray-600 border border-gray-600 rounded cursor-pointer group"
              >
                <span class="flex items-center space-x-2">
                  <i class="fa-solid fa-file-import text-gray-200 group-hover:text-white transition-colors"></i>
                  <span class="text-xs font-bold text-gray-200 group-hover:text-white transition-colors uppercase tracking-wider">
                    Import Image
                  </span>
                </span>
                <input
                  type="file"
                  name="file_upload"
                  class="hidden"
                  accept="image/*"
                  onchange="activateImageStamp(this)"
                />
              </label>
            </div>

            <!-- Divider -->
            <hr class="border-gray-700 my-4 md:my-6">

            <!-- Power Support Section -->
             <h3
              class="text-[10px] md:text-xs font-bold text-gray-500 uppercase tracking-wider mb-2 md:mb-4"
            >
              Power Support
            </h3>
            
            <div class="space-y-3">
               <label class="flex items-center space-x-2 cursor-pointer">
                  <input type="checkbox" id="auto-pole-toggle" class="form-checkbox h-4 w-4 text-blue-600 rounded border-gray-600 bg-gray-700 focus:ring-blue-500 focus:ring-offset-gray-800" onchange="requestAnimationFrame(renderCanvas)">
                  <span class="text-xs font-medium text-gray-200">Auto-place Poles</span>
               </label>
               
               <div class="relative mb-2">
                 <select id="pole-type-select" class="w-full bg-gray-900 text-white text-xs font-bold border border-gray-600 rounded-lg pl-3 pr-8 py-2 outline-none focus:border-blue-500 appearance-none disabled:opacity-50" onchange="requestAnimationFrame(renderCanvas)">
                    <option value="medium-electric-pole" selected>Medium Electric Pole</option>
                    <option value="small-electric-pole">Small Electric Pole</option>
                    <option value="big-electric-pole">Big Electric Pole</option>
                    <option value="substation">Substation</option>
                 </select>
                 <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-400">
                    <i class="fa-solid fa-chevron-down text-[10px]"></i>
                 </div>
               </div>
               
               <div class="relative z-20">
                 <!-- Hidden Input stores the index (0-4) -->
                 <input type="hidden" id="pole-quality-select" value="0">
                 
                 <!-- Main Button -->
                 <button 
                    onclick="toggleQualityDropdown()" 
                    class="w-full bg-gray-900 border border-gray-600 rounded-lg pl-2 pr-3 py-2 flex items-center justify-between hover:border-gray-500 transition-colors focus:outline-none focus:border-blue-500"
                 >
                    <div id="quality-display" class="flex items-center gap-2 text-xs font-bold text-gray-200">
                        <!-- Default Content (Will be updated by init) -->
                        <span>Normal</span>
                    </div>
                    <i class="fa-solid fa-chevron-down text-[10px] text-gray-400"></i>
                 </button>
                 
                 <!-- Dropdown Menu -->
                 <div id="quality-dropdown-menu" class="absolute top-full left-0 w-full mt-1 bg-gray-900 border border-gray-600 rounded-lg shadow-xl hidden overflow-hidden flex flex-col">
                    <!-- Options generated by JS -->
                 </div>
               </div>
               
               <p class="text-[10px] text-gray-500 leading-tight">
                  Automatically overlays poles on export. Poles replace lamps at their location.
               </p>
            </div>
          </div>
        </aside>
      </div>

      <!-- Hidden TextArea for Clipboard -->
      <textarea
        id="clipboard-target"
        class="fixed top-0 left-0 opacity-0 pointer-events-none"
      ></textarea>

    <!-- Help Modal -->
    <div id="help-modal" class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 hidden flex items-center justify-center p-4" onclick="toggleHelp()">
       <div class="bg-gray-800 border border-gray-600 rounded-xl shadow-2xl max-w-lg w-full p-6 relative" onclick="event.stopPropagation()">
          <button onclick="toggleHelp()" class="absolute top-4 right-4 text-gray-400 hover:text-white">
             <i class="fa-solid fa-xmark text-xl"></i>
          </button>
          
          <div class="space-y-6 text-sm text-gray-300">
             
             <!-- Navigation -->
             <div>
                <h3 class="font-bold text-gray-100 mb-2 border-b border-gray-700 pb-1 flex items-center gap-2">
                   <i class="fa-solid fa-arrows-up-down-left-right text-indigo-400"></i> Navigation
                </h3>
                <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                   <div class="flex justify-between"><span>Pan Canvas</span> <span class="bg-gray-700 px-1.5 rounded text-xs text-white">Right Click Drag</span></div>
                   <div class="flex justify-between"><span>Zoom</span> <span class="bg-gray-700 px-1.5 rounded text-xs text-white">Scroll</span></div>
                   <div class="flex justify-between"><span>Pan Tool</span> <span class="bg-gray-700 px-1.5 rounded text-xs text-yellow-500 font-mono">H</span></div>
                </div>
             </div>

             <!-- Tools -->
             <div>
                <h3 class="font-bold text-gray-100 mb-2 border-b border-gray-700 pb-1 flex items-center gap-2">
                   <i class="fa-solid fa-pen-ruler text-indigo-400"></i> Drawing Tools
                </h3>
                <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                   <div class="flex items-center gap-2">
                      <i class="fa-solid fa-pencil text-gray-500"></i>
                      <span>Brush</span> 
                      <span class="ml-auto bg-gray-700 px-1.5 rounded text-xs text-yellow-500 font-mono">B</span>
                   </div>
                   <div class="flex items-center gap-2">
                      <i class="fa-solid fa-fill-drip text-gray-500"></i>
                      <span>Fill (Flood)</span> 
                      <span class="ml-auto bg-gray-700 px-1.5 rounded text-xs text-yellow-500 font-mono">F</span>
                   </div>
                   <div class="flex items-center gap-2">
                      <i class="fa-solid fa-eraser text-gray-500"></i>
                      <span>Eraser</span> 
                      <span class="ml-auto bg-gray-700 px-1.5 rounded text-xs text-yellow-500 font-mono">E</span>
                   </div>
                   <div class="flex items-center gap-2">
                      <i class="fa-solid fa-rotate-left text-gray-500"></i>
                      <span>Undo / Redo</span> 
                      <span class="ml-auto bg-gray-700 px-1.5 rounded text-xs text-yellow-500 font-mono">Ctrl+Z / Shift+Z</span>
                   </div>
                </div>
             </div>

             <!-- Stamping -->
             <div>
                <h3 class="font-bold text-gray-100 mb-2 border-b border-gray-700 pb-1 flex items-center gap-2">
                   <i class="fa-solid fa-stamp text-indigo-400"></i> Stamping (Text & Images)
                </h3>
                <ul class="space-y-2 pl-1">
                   <li class="flex items-start gap-2">
                      <i class="fa-solid fa-fingerprint text-gray-500 text-xs mt-1"></i>
                      <span>
                         <strong>Press & Hold</strong> to preview placement.<br>
                         <strong>Drag</strong> to position precisely.<br>
                         <strong>Release</strong> to stamp onto grid.
                      </span>
                   </li>
                   <li class="flex items-center gap-2"><i class="fa-solid fa-up-right-and-down-left-from-center text-gray-500 text-xs"></i> <span><strong>Mouse Wheel</strong> or <strong>+/-</strong> to resize stamp</span></li>
                   <li class="flex items-center gap-2"><i class="fa-solid fa-ban text-gray-500 text-xs"></i> <span><strong>ESC</strong> to cancel stamp mode</span></li>
                </ul>
             </div>

             <!-- Blueprinting -->
             <div>
                <h3 class="font-bold text-gray-100 mb-2 border-b border-gray-700 pb-1 flex items-center gap-2">
                   <i class="fa-solid fa-clipboard-check text-indigo-400"></i> Exporting
                </h3>
                <div class="text-xs text-gray-400">
                   <p class="mb-1">Click <strong>Copy Blueprint</strong> to generate a Factorio string.</p>
                   <p>Use <strong>Auto-place Poles</strong> to overlay Medium Poles or Substations automatically.</p>
                </div>
             </div>
          </div>
          <div class="mt-6 text-center">
             <button onclick="toggleHelp()" class="px-6 py-2 bg-yellow-600 hover:bg-yellow-500 text-white font-bold rounded-lg transition-colors">Got it!</button>
          </div>
       </div>
    </div>

    <script>
      const FACTORIO_FONT = {
        " ": new Array(48).fill(0),
        "A": [0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "B": [1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,0,0, 0,0,0,0,0,0],
        "C": [0,1,1,1,1,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 0,1,1,1,1,0, 0,0,0,0,0,0],
        "D": [1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,0,0, 0,0,0,0,0,0],
        "E": [1,1,1,1,1,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,1,1,1,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,1,1,1,1,0, 0,0,0,0,0,0],
        "F": [1,1,1,1,1,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,1,1,1,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0],
        "G": [0,1,1,1,1,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,1,1,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0],
        "H": [1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "I": [0,1,1,1,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "J": [0,0,0,0,1,0, 0,0,0,0,1,0, 0,0,0,0,1,0, 0,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "K": [1,0,0,0,1,0, 1,0,0,1,0,0, 1,0,1,0,0,0, 1,1,0,0,0,0, 1,0,1,0,0,0, 1,0,0,1,0,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "L": [1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,1,1,1,1,0, 0,0,0,0,0,0],
        "M": [1,0,0,0,1,0, 1,1,0,1,1,0, 1,0,1,0,1,0, 1,0,1,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "N": [1,0,0,0,1,0, 1,1,0,0,1,0, 1,0,1,0,1,0, 1,0,0,1,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "O": [0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "P": [1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0],
        "Q": [0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,1,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,1],
        "R": [1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,0,0, 1,0,1,0,0,0, 1,0,0,1,0,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "S": [0,1,1,1,1,0, 1,0,0,0,0,0, 1,1,0,0,0,0, 0,0,1,1,0,0, 0,0,0,0,1,0, 0,0,0,0,1,0, 1,1,1,1,0,0, 0,0,0,0,0,0],
        "T": [1,1,1,1,1,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0],
        "U": [1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "V": [1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,0,1,0,0, 0,1,0,1,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0],
        "W": [1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,1,0,1,0, 1,0,1,0,1,0, 1,1,0,1,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "X": [1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,0,1,0,0, 0,0,1,0,0,0, 0,1,0,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "Y": [1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,0,1,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0],
        "Z": [1,1,1,1,1,0, 0,0,0,0,1,0, 0,0,0,1,0,0, 0,0,1,0,0,0, 0,1,0,0,0,0, 1,0,0,0,0,0, 1,1,1,1,1,0, 0,0,0,0,0,0],
        "0": [0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "1": [0,0,1,0,0,0, 0,1,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "2": [0,1,1,1,0,0, 1,0,0,0,1,0, 0,0,0,0,1,0, 0,0,0,1,0,0, 0,0,1,0,0,0, 0,1,0,0,0,0, 1,1,1,1,1,0, 0,0,0,0,0,0],
        "3": [0,1,1,1,0,0, 1,0,0,0,1,0, 0,0,0,0,1,0, 0,0,1,1,0,0, 0,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "4": [0,0,0,1,0,0, 0,0,1,1,0,0, 0,1,0,1,0,0, 1,0,0,1,0,0, 1,1,1,1,1,0, 0,0,0,1,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0],
        "5": [1,1,1,1,1,0, 1,0,0,0,0,0, 1,1,1,1,0,0, 0,0,0,0,1,0, 0,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "6": [0,1,1,1,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "7": [1,1,1,1,1,0, 1,0,0,0,1,0, 0,0,0,0,1,0, 0,0,0,1,0,0, 0,0,1,0,0,0, 0,1,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0],
        "8": [0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "9": [0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,1,0, 0,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "!": [0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        ".": [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        ",": [0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0, 0,0,1,0,0,0, 0,1,0,0,0,0, 0,0,0,0,0,0],
        "?": [0,1,1,1,0,0, 1,0,0,0,1,0, 0,0,0,0,1,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,1,0,0, 0,0,0,0,0,0, 0,0,0,0,0,0],
        "a": [0,0,0,0,0,0, 0,1,1,1,0,0, 0,0,0,0,1,0, 0,1,1,1,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0],
        "b": [1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,1,1,0,0, 1,1,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,0,0, 0,0,0,0,0,0],
        "c": [0,0,0,0,0,0, 0,0,1,1,1,0, 0,1,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 0,1,0,0,0,0, 0,0,1,1,0,0, 0,0,0,0,0,0],
        "d": [0,0,0,0,1,0, 0,0,0,0,1,0, 0,0,1,1,1,0, 0,1,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0],
        "e": [0,0,0,0,0,0, 0,1,1,1,0,0, 1,0,0,0,1,0, 1,1,1,1,1,0, 1,0,0,0,0,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "f": [0,0,1,1,0,0, 0,1,0,0,0,0, 1,1,1,1,0,0, 0,1,0,0,0,0, 0,1,0,0,0,0, 0,1,0,0,0,0, 1,1,1,0,0,0, 0,0,0,0,0,0],
        "g": [0,0,0,0,0,0, 0,0,1,1,1,0, 0,1,0,0,0,1, 0,1,0,0,0,1, 0,0,1,1,1,1, 0,0,0,0,0,1, 0,1,1,1,1,0, 0,0,0,0,0,0],
        "h": [1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,1,1,0,0, 1,1,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "i": [0,0,1,0,0,0, 0,0,0,0,0,0, 0,1,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "j": [0,0,1,1,0,0, 0,0,0,0,0,0, 0,0,1,1,0,0, 0,0,0,1,0,0, 0,0,0,1,0,0, 1,0,0,1,0,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "k": [1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,1,0,0, 1,0,1,0,0,0, 1,1,0,0,0,0, 1,0,1,0,0,0, 1,0,0,1,0,0, 0,0,0,0,0,0],
        "l": [0,1,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "m": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,1,0,1,1,0, 1,0,1,0,1,0, 1,0,1,0,1,0, 1,0,1,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "n": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "o": [0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,0,0, 0,0,0,0,0,0],
        "p": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,1,1,1,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,1,1,1,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0],
        "q": [0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,1,1,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,1,0, 0,0,0,0,1,0],
        "r": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,1,1,1,0, 1,1,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 1,0,0,0,0,0, 0,0,0,0,0,0],
        "s": [0,0,0,0,0,0, 0,0,0,0,0,0, 0,1,1,1,1,0, 1,0,0,0,0,0, 0,1,1,1,0,0, 0,0,0,0,1,0, 1,1,1,1,0,0, 0,0,0,0,0,0],
        "t": [0,0,1,0,0,0, 0,1,1,1,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,1,0,0,0, 0,0,0,1,1,0, 0,0,0,0,0,0],
        "u": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,0,0],
        "v": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,0,1,0,0, 0,0,1,0,0,0, 0,0,0,0,0,0],
        "w": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 1,0,1,0,1,0, 0,1,0,1,0,0, 0,0,0,0,0,0],
        "x": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,1,0, 0,1,0,1,0,0, 0,0,1,0,0,0, 0,1,0,1,0,0, 1,0,0,0,1,0, 0,0,0,0,0,0],
        "y": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,0,0,0,1,0, 1,0,0,0,1,0, 0,1,1,1,1,0, 0,0,0,0,1,0, 1,1,1,1,0,0, 0,0,0,0,0,0],
        "z": [0,0,0,0,0,0, 0,0,0,0,0,0, 1,1,1,1,1,0, 0,0,0,1,0,0, 0,0,1,0,0,0, 0,1,0,0,0,0, 1,1,1,1,1,0, 0,0,0,0,0,0]
      };

      function hexToRgb(hex) {
        const bigint = parseInt(hex.replace("#", ""), 16);
        return { r: (bigint >> 16) & 255, g: (bigint >> 8) & 255, b: bigint & 255 };
      }

      function encodeBlueprint(blueprintJson) {
        try {
          const jsonString = JSON.stringify(blueprintJson);
          const utf8Encoder = new TextEncoder();
          const jsonBytes = utf8Encoder.encode(jsonString);
          const compressed = pako.deflate(jsonBytes, { level: 9 });
          return "0" + btoa(Array.from(compressed).map(b => String.fromCharCode(b)).join(""));
        } catch (e) {
          console.error(e);
          return null;
        }
      }

      function refreshStampBuffer() {
         if (stampMode === 'image' && stampSourceImage) {
            const targetW = Math.max(1, Math.floor(stampBaseSize.w * stampScale));
            const targetH = Math.max(1, Math.floor(stampBaseSize.h * stampScale));
            const oc = document.createElement("canvas");
            oc.width = targetW; oc.height = targetH;
            const octx = oc.getContext("2d");
            octx.imageSmoothingEnabled = true; octx.imageSmoothingQuality = 'high';
            octx.drawImage(stampSourceImage, 0, 0, targetW, targetH);
            const data = octx.getImageData(0, 0, targetW, targetH).data;
            const buffer = new Array(targetH).fill(null).map(() => new Array(targetW).fill(null));
            for (let y = 0; y < targetH; y++) {
               for (let x = 0; x < targetW; x++) {
                  const i = (y * targetW + x) * 4;
                  if (data[i + 3] > 128) {
                      const hex = "#" + ((1 << 24) + (data[i] << 16) + (data[i + 1] << 8) + data[i + 2]).toString(16).slice(1);
                      buffer[y][x] = hex;
                  }
               }
            }
            stampBuffer = { w: targetW, h: targetH, data: buffer };
         }
      }

      document.addEventListener("keydown", (e) => {
         // Allow hotkeys unless typing in a text field
         const tag = document.activeElement.tagName;
         const type = document.activeElement.type;
         const isTextInput = tag === "TEXTAREA" || (tag === "INPUT" && /^(text|number|password|email|search)$/i.test(type));
         if (isTextInput) return;
         const key = e.key.toLowerCase();
         if (key === "h") setDrawTool('pan');
         if (key === "b") setDrawTool('brush');
         if (key === "f") setDrawTool('fill');
         if (key === "e") setDrawTool('erase');
         if ((e.ctrlKey || e.metaKey) && key === "z") {
            e.preventDefault();
            if (e.shiftKey) redo(); else undo();
         }
         if (stampMode) {
             if (e.key === "+" || e.key === "=" || e.key === "]") {
                 if (stampMode === 'text') stampScale++;
                 else stampScale = parseFloat((stampScale + 0.1).toFixed(1));
                 refreshStampBuffer();
                 requestAnimationFrame(renderCanvas);
             }
             if (e.key === "-" || e.key === "_" || e.key === "[") {
                 if (stampMode === 'text') stampScale = Math.max(1, stampScale - 1);
                 else stampScale = Math.max(0.1, parseFloat((stampScale - 0.1).toFixed(1)));
                 refreshStampBuffer();
                 requestAnimationFrame(renderCanvas);
             }
             if (e.key === "Escape") {
                 stampMode = null;
                 document.getElementById("stamp-hint").classList.add("hidden");
                 canvas.style.cursor = "crosshair";
                 requestAnimationFrame(renderCanvas);
             }
         }
      });

      const PIXEL_SIZE = 20;
      const GRID_W = 513;
      const GRID_H = 513;
      
      // --- Quality & Pole Data (Factorio 2.0) ---
      const POLE_DATA = {
         "small-electric-pole":  { size: 1, offset: 3, supply: [5, 7, 9, 11, 15],      wire: [7.5, 9.5, 11.5, 13.5, 17.5] },
         "medium-electric-pole": { size: 1, offset: 3, supply: [7, 9, 11, 13, 17],     wire: [9, 11, 13, 15, 19] },
         "big-electric-pole":    { size: 2, offset: 1, supply: [4, 6, 8, 10, 14],      wire: [32, 34, 36, 38, 42] },
         "substation":           { size: 2, offset: 8, supply: [18, 20, 22, 24, 28],   wire: [18, 20, 22, 24, 28] }
      };
      
      const QUALITY_NAMES = ["normal", "uncommon", "rare", "epic", "legendary"];
      const QUALITY_COLORS = ["#9ca3af", "#22c55e", "#3b82f6", "#a855f7", "#f97316"]; // Gray, Green, Blue, Purple, Orange
      
      const QUALITY_IMAGES = [
         "assets/15px-Quality_normal.png",
         "assets/15px-Quality_uncommon.png",
         "assets/15px-Quality_rare.png",
         "assets/15px-Quality_epic.png",
         "assets/15px-Quality_legendary.png"
      ];

      let gridData = [];
      let drawHistory = [];
      let historyIndex = -1;
      let currentDrawTool = "brush";
      let isMouseDown = false;
      let stampMode = null;
      let stampBuffer = null;
      let stampScale = 1;
      let stampSourceImage = null;
      let stampBaseSize = { w: 0, h: 0 };
      let cameraOffset = { x: 0, y: 0 };
      let cameraZoom = 0.8;
      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      let cameraStart = { x: 0, y: 0 };
      const canvas = document.getElementById("gridCanvas");
      const ctx = canvas.getContext("2d", { alpha: false });
      const viewport = document.getElementById("viewport");

      function createEmptyGrid(w, h) {
        const rows = new Array(h);
        for(let y=0; y<h; y++) rows[y] = new Array(w).fill(null);
        return rows;
      }

      function initDraw() {
        gridData = createEmptyGrid(GRID_W, GRID_H);
        const centerX = (GRID_W * PIXEL_SIZE) / 2;
        const centerY = (GRID_H * PIXEL_SIZE) / 2;
        cameraOffset = { x: centerX, y: centerY };
        saveState();
        window.requestAnimationFrame(renderCanvas);
      }

      function saveState() {
         const snapshot = gridData.map(row => row.slice());
         if (historyIndex < drawHistory.length - 1) {
            drawHistory = drawHistory.slice(0, historyIndex + 1);
         }
         drawHistory.push(snapshot);
         if (drawHistory.length > 20) drawHistory.shift();
         else historyIndex++;
      }

      function undo() {
        if (historyIndex > 0) {
          historyIndex--;
          gridData = drawHistory[historyIndex].map(row => row.slice());
          renderCanvas();
        }
      }

      function redo() {
        if (historyIndex < drawHistory.length - 1) {
          historyIndex++;
          gridData = drawHistory[historyIndex].map(row => row.slice());
          renderCanvas();
        }
      }
      
      function clearCanvas() {
         gridData = createEmptyGrid(GRID_W, GRID_H);
         saveState();
         renderCanvas();
      }

      function renderCanvas() {
         const vw = Math.floor(viewport.clientWidth);
         const vh = Math.floor(viewport.clientHeight);
         
         if (canvas.width !== vw || canvas.height !== vh) {
            canvas.width = vw;
            canvas.height = vh;
         }

         const w = canvas.width;
         const h = canvas.height;
         
         // Background
         ctx.fillStyle = "#111827";
         ctx.fillRect(0, 0, w, h);

         ctx.save();
         
         // 2. Apply Camera Transform
         // We want cameraOffset to be at the center of the screen
         ctx.translate(w / 2, h / 2);
         ctx.scale(cameraZoom, cameraZoom);
         ctx.translate(-cameraOffset.x, -cameraOffset.y);
         
         // 3. Calculate Visible Bounds (Culling)
         // Inverse transform screen corners to world
         // Screen Rect: (0,0) to (w,h)
         // World = (Screen - Center) / Zoom + Camera
         const screenL = 0;
         const screenR = w;
         const screenT = 0;
         const screenB = h;
         
         const worldL = (screenL - w/2) / cameraZoom + cameraOffset.x;
         const worldR = (screenR - w/2) / cameraZoom + cameraOffset.x;
         const worldT = (screenT - h/2) / cameraZoom + cameraOffset.y;
         const worldB = (screenB - h/2) / cameraZoom + cameraOffset.y;
         
         // Convert to Tile Coordinates
         const minTileX = Math.max(0, Math.floor(worldL / PIXEL_SIZE));
         const maxTileX = Math.min(GRID_W - 1, Math.floor(worldR / PIXEL_SIZE) + 1);
         const minTileY = Math.max(0, Math.floor(worldT / PIXEL_SIZE));
         const maxTileY = Math.min(GRID_H - 1, Math.floor(worldB / PIXEL_SIZE) + 1);

         // 4. Draw Grid
         ctx.lineWidth = 1; // zoomed line width? No, keep 1px
         // To keep lines sharp, we might want inverse scaling, but simple is fine.
         
         // Chunk Lines (Every 32 tiles - Factorio Chunk)
         // We draw these more visible
         ctx.strokeStyle = "#374151"; 
         ctx.lineWidth = 2 / cameraZoom; // Keep visual width constant
         
         ctx.beginPath();
         // Draw Vertical Chunk Lines
         const startChunkX = Math.floor(minTileX / 32) * 32;
         for (let x = startChunkX; x <= maxTileX; x += 32) {
            ctx.moveTo(x * PIXEL_SIZE, minTileY * PIXEL_SIZE);
            ctx.lineTo(x * PIXEL_SIZE, (maxTileY + 1) * PIXEL_SIZE);
         }
         // Draw Horizontal Chunk Lines
         const startChunkY = Math.floor(minTileY / 32) * 32;
         for (let y = startChunkY; y <= maxTileY; y += 32) {
            ctx.moveTo(minTileX * PIXEL_SIZE, y * PIXEL_SIZE);
            ctx.lineTo((maxTileX + 1) * PIXEL_SIZE, y * PIXEL_SIZE);
         }
         ctx.stroke();

         // Normal Grid Lines (Every 1 tile) - Faint
         if (cameraZoom > MIN_DETAIL_ZOOM) { // Only draw detailed grid if zoomed in enough
             ctx.strokeStyle = "#1f2937";
             ctx.lineWidth = 1 / cameraZoom;
             ctx.beginPath();
             for (let x = minTileX; x <= maxTileX; x++) {
                if (x % 32 === 0) continue; // Skip chunk lines
                ctx.moveTo(x * PIXEL_SIZE, minTileY * PIXEL_SIZE);
                ctx.lineTo(x * PIXEL_SIZE, (maxTileY + 1) * PIXEL_SIZE);
             }
             for (let y = minTileY; y <= maxTileY; y++) {
                if (y % 32 === 0) continue;
                ctx.moveTo(minTileX * PIXEL_SIZE, y * PIXEL_SIZE);
                ctx.lineTo((maxTileX + 1) * PIXEL_SIZE, y * PIXEL_SIZE);
             }
             ctx.stroke();
         }

         // 5. Active Pixels (Culled Loop)
         for (let y = minTileY; y <= maxTileY; y++) {
             // Optimization: Check row validity first? gridData is dense 2D array, fast access.
             for (let x = minTileX; x <= maxTileX; x++) {
                 const color = gridData[y][x];
                 if (color) {
                     ctx.fillStyle = color;
                     // Slight inset for grid look
                     ctx.fillRect(
                         x * PIXEL_SIZE + 0.5, 
                         y * PIXEL_SIZE + 0.5, 
                         PIXEL_SIZE - 1, 
                         PIXEL_SIZE - 1
                     );
                 }
             }
         }

         // 6. Overlays (Stamps, Poles)
         // Only draw if within bounds (or just draw and let canvas clip)
         
         // Stamp Ghost
         if (stampMode && stampBuffer) {
             const worldPos = getWorldCoords(lastMouseEvt);
             const cx = Math.floor(worldPos.x / PIXEL_SIZE);
             const cy = Math.floor(worldPos.y / PIXEL_SIZE);
             
             let renderScale = 1;
             let drawW = stampBuffer.w;
             let drawH = stampBuffer.h;
             
             if (stampMode === 'text') {
                renderScale = stampScale;
                drawW = stampBuffer.w * renderScale;
                drawH = stampBuffer.h * renderScale;
             }
             
             const startX = cx - Math.floor(drawW / 2);
             const startY = cy - Math.floor(drawH / 2);
             
             ctx.globalAlpha = 0.5;
             
             // Draw stamp pixels
             for (let sy = 0; sy < stampBuffer.h; sy++) {
               for (let sx = 0; sx < stampBuffer.w; sx++) {
                 const col = stampBuffer.data[sy][sx];
                 if (col) {
                   const originX = startX + (sx * renderScale);
                   const originY = startY + (sy * renderScale);
                   // Simple culling check
                   if (originX > maxTileX || originX + renderScale < minTileX) continue;
                   if (originY > maxTileY || originY + renderScale < minTileY) continue;
                   
                   ctx.fillStyle = col;
                   ctx.fillRect(originX * PIXEL_SIZE, originY * PIXEL_SIZE, PIXEL_SIZE * renderScale, PIXEL_SIZE * renderScale);
                 }
               }
             }
             ctx.globalAlpha = 1.0;
             
             // Box
             ctx.strokeStyle = "#fbbf24"; 
             ctx.lineWidth = 2 / cameraZoom;
             ctx.strokeRect(startX * PIXEL_SIZE, startY * PIXEL_SIZE, drawW * PIXEL_SIZE, drawH * PIXEL_SIZE);
         }
         
         // Poles
         const autoPole = document.getElementById('auto-pole-toggle')?.checked;
         if (autoPole) {
             const type = document.getElementById('pole-type-select').value;
             const qualityIdx = parseInt(document.getElementById('pole-quality-select').value);
             const data = POLE_DATA[type];
             
             const coverage = data.supply[qualityIdx]; // Width/Height of supply area
             const size = data.size;
             const offset = Math.floor((coverage - 1) / 2);

             // We need to calculate poles based on visible range + margin
             // We'll pass the visible bounds to `calculateActivePoles` to optimize!
             
             const poles = calculateActivePoles(type, qualityIdx, minTileX, minTileY, maxTileX, maxTileY);
             
             poles.forEach(p => {
                 const x = p.x;
                 const y = p.y;
                 ctx.strokeStyle = "#3b82f6";
                 ctx.lineWidth = 2 / cameraZoom;
                 ctx.strokeRect(x * PIXEL_SIZE + 1, y * PIXEL_SIZE + 1, size * PIXEL_SIZE - 2, size * PIXEL_SIZE - 2);
                 
                 ctx.lineWidth = 1 / cameraZoom;
                 ctx.setLineDash([4/cameraZoom, 4/cameraZoom]);
                 // Draw Supply Area
                 // Supply area is centered on the pole.
                 // If pole is at (x,y) (top-left of pole entity).
                 // Supply area rectangle:
                 // Supply is 'coverage' x 'coverage'.
                 // The supply area center is center of pole.
                 // Pole center: x + size/2, y + size/2.
                 // Supply rect top-left: (x + size/2 - coverage/2), (y + size/2 - coverage/2)
                 const supplyX = x + size/2 - coverage/2;
                 const supplyY = y + size/2 - coverage/2;
                 
                 ctx.strokeRect(supplyX*PIXEL_SIZE, supplyY*PIXEL_SIZE, coverage*PIXEL_SIZE, coverage*PIXEL_SIZE);
                 ctx.setLineDash([]);
             });
         }

         ctx.restore();
      }

      // Updated Connected Pole Logic (Steiner Tree Approximation)
      function calculateActivePoles(type, qualityIdx, boundsMinX, boundsMinY, boundsMaxX, boundsMaxY) {
         // 1. Initial Scan: Find all "Required" poles to cover lamps
         const data = POLE_DATA[type];
         const coverage = data.supply[qualityIdx]; 
         const reach = data.wire[qualityIdx]; 
         // Align offset to match rendering logic
         const offset = Math.floor((coverage - 1) / 2);
         
         const margin = coverage + 5;
         const searchMinX = Math.max(0, boundsMinX - margin);
         const searchMaxX = Math.min(GRID_W, boundsMaxX + margin);
         const searchMinY = Math.max(0, boundsMinY - margin);
         const searchMaxY = Math.min(GRID_H, boundsMaxY + margin);

         const areaHasLamp = (px, py, w, h) => {
             const sx = Math.max(0, px);
             const sy = Math.max(0, py);
             const ex = Math.min(GRID_W, px+w);
             const ey = Math.min(GRID_H, py+h);
             for(let y=sy; y<ey; y++) {
                 for(let x=sx; x<ex; x++) {
                     if(gridData[y][x]) return true;
                 }
             }
             return false;
         };
         
         let activePoles = [];
         
         // Align grid to 0,0
         const startX = Math.floor((searchMinX) / coverage) * coverage + offset;
         const startY = Math.floor((searchMinY) / coverage) * coverage + offset;
         
         for(let y = startY; y <= searchMaxY; y+=coverage) {
             for(let x = startX; x <= searchMaxX; x+=coverage) {
                 if (areaHasLamp(x - offset, y - offset, coverage, coverage)) {
                     activePoles.push({x, y, id: activePoles.length, group: activePoles.length});
                 }
             }
         }

         if (activePoles.length === 0) return [];

         // 2. Connectivity Graph - Union-Find Components
         // We need to connect all these islands.
         // Simple strategy: Merge closest components until 1 remains.
         
         // Helper to find distances
         const getDist = (p1, p2) => Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y); // Manhattan is good for grid
         const getWireDist = (p1, p2) => Math.max(Math.abs(p1.x - p2.x), Math.abs(p1.y - p2.y)); // Chebyshev for square reach? No, Factorio is Euclidean-ish but logic checks max axial usually? Actually Factorio wire reach is circular/Euclidean. 
         // Medium Pole: Range 9 (Euclidean). sqrt(dx^2 + dy^2) <= 9. 
         // For grid placement (rectilinear), let's stick to simple placement.
         // If we place poles every REACH distance in a line, they connect.
         
         // Group management
         let groups = []; 
         activePoles.forEach(p => {
             p.group = groups.length;
             groups.push([p]);
         });

         const findGroup = (pole) => {
             for(let i=0; i<groups.length; i++) {
                 if(groups[i].includes(pole)) return i;
             }
             return -1;
         };

         // Initial Merge based on strict range (are they already connected?)
         // This is O(N^2), but N (poles) is usually small (<1000).
         for (let i = 0; i < activePoles.length; i++) {
             for (let j = i + 1; j < activePoles.length; j++) {
                 const p1 = activePoles[i];
                 const p2 = activePoles[j];
                 const dist = Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                 if (dist <= reach) {
                     // Merge groups
                     const g1 = findGroup(p1);
                     const g2 = findGroup(p2);
                     if (g1 !== g2) {
                         const merged = groups[g1].concat(groups[g2]);
                         groups[g2] = []; // clear old
                         groups[g1] = merged; // update new
                     }
                 }
             }
         }
         // Cleanup empty groups
         groups = groups.filter(g => g.length > 0);

         // 3. Bridge the Gap
         // While > 1 group, find closest pair of nodes from distinct groups and build a bridge.
         while(groups.length > 1) {
             let minD = Infinity;
             let bestPair = null;
             let bestG1 = -1;
             let bestG2 = -1;

             // Find closest groups
             for(let i=0; i<groups.length; i++) {
                 for(let j=i+1; j<groups.length; j++) {
                     // Check all pairs? Optimization: Check centroids? No, edges might be closer.
                     // Brute force is safe for reasonable N.
                     for(let p1 of groups[i]) {
                         for(let p2 of groups[j]) {
                             const d = Math.abs(p1.x - p2.x) + Math.abs(p1.y - p2.y);
                             if (d < minD) {
                                 minD = d;
                                 bestPair = {p1, p2};
                                 bestG1 = i;
                                 bestG2 = j;
                             }
                         }
                     }
                 }
             }

             if (!bestPair) break; // Should not happen

             // Build Bridge
             const start = bestPair.p1;
             const end = bestPair.p2;
             
             // Simple L-shape routing
             // We step by `reach` (or slightly less to be safe) to place bridge poles.
             // Safe reach step = reach - 0.5? Logic:
             const step = reach; 
             
             let cx = start.x;
             let cy = start.y;
             
             const bridgePoles = [];
             
             // Move X
             while (Math.abs(cx - end.x) > step) {
                 cx += Math.sign(end.x - cx) * step;
                 bridgePoles.push({x: cx, y: cy});
             }
             cx = end.x;
             // Corner pole if needed (if we turned)? 
             // Actually if we move X then Y, we might need a pole at the corner (end.x, start.y)
             // Check if dist from last point to (end.x, start.y) is ok.
             
             // If we just snapped cx to end.x, check dist.
             // If distance from (prevX, cy) to (end.x, cy) > reach, we added intermediate.
             // Now we are at (end.x, cy).
             
             // Move Y
             while (Math.abs(cy - end.y) > step) {
                 cy += Math.sign(end.y - cy) * step;
                 bridgePoles.push({x: cx, y: cy});
             }
             
             // Add bridge poles to G1 and merge G1/G2
             // Filter duplicates?
             bridgePoles.forEach(bp => {
                 // Check if valid? (Bounds? Overlap?)
                 // Add to result if unique
                 if (!activePoles.some(ap => ap.x === bp.x && ap.y === bp.y)) {
                     const newPole = {x: bp.x, y: bp.y, id: -1}; // temporary ID
                     activePoles.push(newPole);
                     groups[bestG1].push(newPole);
                 }
             });
             
             // Merge
             groups[bestG1] = groups[bestG1].concat(groups[bestG2]);
             groups.splice(bestG2, 1);
         }
         
         return activePoles;
      }

      // --- Interaction Logic ---
      
      // Store last event for render loop usage
      let lastMouseEvt = { clientX: 0, clientY: 0 };

      function getWorldCoords(e) {
         const rect = canvas.getBoundingClientRect();
         // Screen relative to canvas center
         const screenX = e.clientX - rect.left;
         const screenY = e.clientY - rect.top;
         
         // Transform: World = (Screen - Center) / Zoom + Camera
         const w = canvas.width;
         const h = canvas.height;
         const worldX = (screenX - w/2) / cameraZoom + cameraOffset.x;
         const worldY = (screenY - h/2) / cameraZoom + cameraOffset.y;
         
         return { x: worldX, y: worldY };
      }

      function startDraw(e) {
         lastMouseEvt = e;
         // Right Click -> Pan
         if (e.button === 2) {
             e.preventDefault();
             isPanning = true;
             panStart = { x: e.clientX, y: e.clientY };
             cameraStart = { ...cameraOffset };
             canvas.style.cursor = "grabbing";
             return;
         }
         
         // Draw OR Pan Tool (Left Click)
         if (e.button === 0) {
             e.preventDefault(); // Prevent default drag/select behavior
             
             // 1. Stamp Mode takes priority over tools
             if (stampMode) {
                 // Wait for release to commit (or if we want 'click to stamp', handle it in endDraw or here)
                 // Just returning ensures we don't start panning or drawing strokes.
                 return;
             }

             // 2. Pan Tool
             if (currentDrawTool === 'pan') {
                 isPanning = true;
                 panStart = { x: e.clientX, y: e.clientY };
                 cameraStart = { ...cameraOffset };
                 canvas.style.cursor = "grabbing";
                 return;
             }

             const world = getWorldCoords(e);
             const gx = Math.floor(world.x / PIXEL_SIZE);
             const gy = Math.floor(world.y / PIXEL_SIZE);
             
             if (currentDrawTool === 'fill') {
                 useTool(gx, gy);
             } else {
                 isMouseDown = true;
                 useTool(gx, gy);
             }
         }
      }

      // Paste Handler
      window.addEventListener('paste', (e) => {
          const items = (e.clipboardData || e.originalEvent.clipboardData).items;
          for (const item of items) {
              if (item.type.indexOf('image') !== -1) {
                  const blob = item.getAsFile();
                  processImageFile(blob);
                  // Switch to stamp mode automatically logic is inside processImageFile
                  // But we might need to reset tool if it was 'pan'? 
                  // processImageFile sets stampMode='image', which now overrides pan in startDraw.
              }
          }
      });

      function moveDraw(e) {
         lastMouseEvt = e;
         
         if (isPanning) {
             e.preventDefault();
             const dx = (e.clientX - panStart.x) / cameraZoom; // Screenspace delta -> Worldspace delta
             const dy = (e.clientY - panStart.y) / cameraZoom;
             
             cameraOffset.x = cameraStart.x - dx;
             cameraOffset.y = cameraStart.y - dy;
             // No limits? Infinite canvas.
             requestAnimationFrame(renderCanvas);
             return;
         }

         const world = getWorldCoords(e);
         const gx = Math.floor(world.x / PIXEL_SIZE);
         const gy = Math.floor(world.y / PIXEL_SIZE);
         
         // Clamp for display
         const dispX = Math.max(0, Math.min(GRID_W-1, gx));
         const dispY = Math.max(0, Math.min(GRID_H-1, gy));
         document.getElementById("coords").textContent = `X: ${dispX}, Y: ${dispY}`;

         if (stampMode) {
            requestAnimationFrame(renderCanvas);
         } else if (isMouseDown) {
             useTool(gx, gy); // useTool calls renderCanvas
         } else {
             // Redraw for cursor highlights if we add them, or stamp ghost
             // requestAnimationFrame(renderCanvas);
         }
      }

      function endDraw(e) {
           if (stampMode) {
              commitStamp();
              return;
           }
           if (isPanning) {
              isPanning = false;
              if (currentDrawTool === 'pan') canvas.style.cursor = "grab";
              else canvas.style.cursor = stampMode ? "none" : (currentDrawTool === "fill" ? "alias" : "crosshair");
          }
          if (isMouseDown) {
              isMouseDown = false;
              saveState();
          }
      }
      
       // Zoom
       const MIN_ZOOM = 0.1;
       const MAX_ZOOM = 3.0;
       const MIN_DETAIL_ZOOM = 0.3;

       window.addEventListener("wheel", (e) => {
          e.preventDefault();
          const delta = e.deltaY < 0 ? 1 : -1;

          if (stampMode) {
              const change = delta * 0.1;
              if (stampMode === 'text') {
                  stampScale = Math.max(1, stampScale + Math.sign(change));
              } else {
                  stampScale = Math.max(0.1, parseFloat((stampScale + change).toFixed(1)));
              }
              refreshStampBuffer();
              requestAnimationFrame(renderCanvas);
              return;
          }

          const zoomIntensity = 0.1;
          const newZoom = Math.min(Math.max(MIN_ZOOM, cameraZoom + (delta * zoomIntensity * cameraZoom)), MAX_ZOOM);
          
          if (newZoom !== cameraZoom) {
            // Zoom towards mouse
            // 1. Mouse World Pos before zoom
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const w = canvas.width;
            const h = canvas.height;
            
            const worldBeforeX = (mouseX - w/2) / cameraZoom + cameraOffset.x;
            const worldBeforeY = (mouseY - h/2) / cameraZoom + cameraOffset.y;
            
            cameraZoom = newZoom;
            
            // 2. Adjust Camera Offset so World Pos is same under mouse
            cameraOffset.x = worldBeforeX - (mouseX - w/2) / cameraZoom;
            cameraOffset.y = worldBeforeY - (mouseY - h/2) / cameraZoom;
            
            requestAnimationFrame(renderCanvas);
         }
      }, { passive: false });

      // Resize Handler
      window.addEventListener("resize", () => {
         requestAnimationFrame(renderCanvas);
      });
      
      // Event Listeners
      canvas.addEventListener("contextmenu", e => e.preventDefault());
      canvas.addEventListener("mousedown", startDraw);
      canvas.addEventListener("mousemove", moveDraw);
      window.addEventListener("mouseup", endDraw);
      
      // Touch Support (Mapped to Mouse)
      function touchHandler(e) {
          if (e.type !== 'touchend') e.preventDefault();
          const touch = e.touches[0] || e.changedTouches[0];
          const typeMap = {
              'touchstart': 'mousedown',
              'touchmove': 'mousemove',
              'touchend': 'mouseup'
          };
          
          const mouseEvent = new MouseEvent(typeMap[e.type], {
              clientX: touch.clientX,
              clientY: touch.clientY,
              button: 0 // Simulate Left Click
          });
          
          if (e.type === 'touchstart') startDraw(mouseEvent);
          if (e.type === 'touchmove') moveDraw(mouseEvent);
          if (e.type === 'touchend') endDraw(mouseEvent);
      }
      
      canvas.addEventListener("touchstart", touchHandler, {passive: false});
      canvas.addEventListener("touchmove", touchHandler, {passive: false});
      canvas.addEventListener("touchend", touchHandler, {passive: false});

      // --- Tools Logic (Partial) ---
      function setDrawTool(tool) {
        currentDrawTool = tool;
        stampMode = null;
        document.getElementById("stamp-hint").classList.add("hidden");

        ["brush", "fill", "erase", "pan"].forEach((t) =>
          document.getElementById(`btn-${t}`).classList.remove("active")
        );
        document.getElementById(`btn-${tool}`).classList.add("active");
        
        if (tool === "pan") canvas.style.cursor = "grab";
        else if (tool === "fill") canvas.style.cursor = "alias";
        else canvas.style.cursor = "crosshair";
      }

      function useTool(x, y) {
        if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return;
        const color = document.getElementById("draw-color").value;

        let changed = false;
        if (currentDrawTool === "brush") {
          if (gridData[y][x] !== color) {
            gridData[y][x] = color;
            changed = true;
          }
        } else if (currentDrawTool === "erase") {
          if (gridData[y][x] !== null) {
            gridData[y][x] = null;
            changed = true;
          }
        } 
        
        if (changed) requestAnimationFrame(renderCanvas);
        
        if (currentDrawTool === "fill") {
          floodFill(x, y, color);
          requestAnimationFrame(renderCanvas);
          saveState();
        }
      }

      function floodFill(sx, sy, fillColor) {
        const targetColor = gridData[sy][sx];
        if (targetColor === fillColor) return;

        const stack = [[sx, sy]];
        while (stack.length) {
          const [x, y] = stack.pop();
          if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) continue;
          if (gridData[y][x] !== targetColor) continue;

          gridData[y][x] = fillColor;
          stack.push([x + 1, y], [x - 1, y], [x, y + 1], [x, y - 1]);
        }
      }

      function commitStamp() {
         if (!stampMode || !stampBuffer) return;
         const world = getWorldCoords(lastMouseEvt);
         const cx = Math.floor(world.x / PIXEL_SIZE);
         const cy = Math.floor(world.y / PIXEL_SIZE);
         
         let renderScale = 1;
         let drawW = stampBuffer.w;
         let drawH = stampBuffer.h;
         if (stampMode === 'text') {
            renderScale = stampScale;
            drawW = stampBuffer.w * renderScale;
            drawH = stampBuffer.h * renderScale;
         }
         
         const startX = cx - Math.floor(drawW / 2);
         const startY = cy - Math.floor(drawH / 2);
         let changed = false;
         
         for (let sy = 0; sy < stampBuffer.h; sy++) {
            for (let sx = 0; sx < stampBuffer.w; sx++) {
               const col = stampBuffer.data[sy][sx];
               if (col) {
                  for(let dy=0; dy<renderScale; dy++) {
                     for(let dx=0; dx<renderScale; dx++) {
                        const gx = startX + sx*renderScale + dx;
                        const gy = startY + sy*renderScale + dy;
                        if(gx>=0 && gx<GRID_W && gy>=0 && gy<GRID_H) {
                           gridData[gy][gx] = col;
                           changed = true;
                        }
                     }
                  }
               }
            }
         }
         
         if (changed) saveState();
         stampMode = null;
         document.getElementById("stamp-hint").classList.add("hidden");
         isMouseDown = false;
         canvas.style.cursor = "crosshair";
         requestAnimationFrame(renderCanvas);
      }
      
      // Stamp Generators
      function activateTextStamp() {
        const text = document.getElementById("draw-text-input").value;
        if (!text) return;
        const color = document.getElementById("draw-color").value;

        let w = 0;
        const h = 8;
        if (text.length > 0) {
           w = (text.length * 6) + (Math.max(0, text.length - 1));
        }

        const buffer = new Array(h)
          .fill(null)
          .map(() => new Array(w).fill(null));

        let cursor = 0;
        for (let idx = 0; idx < text.length; idx++) {
          const char = text[idx];
          const map = FACTORIO_FONT[char] || FACTORIO_FONT["?"];
          
          if (!map) {
             cursor += 7;
             continue;
          }
           
          // Safety: ensure map is 48 length (6x8)
          const charMap = map.length === 48 ? map : FACTORIO_FONT["?"];

          for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 6; c++) {
              if (charMap[r * 6 + c]) buffer[r][cursor + c] = color;
            }
          }
          cursor += 7; 
        }
        
        stampScale = 1; 
        stampBuffer = { w, h, data: buffer };
        stampMode = "text";
        document.getElementById("stamp-hint").classList.remove("hidden");
        canvas.style.cursor = "none";
      }

      function activateImageStamp(input) {
        if (input.files && input.files[0]) {
           processImageFile(input.files[0]);
           input.value = ""; 
        }
      }
      
      function processImageFile(file) {
         const reader = new FileReader();
         reader.onload = function(e) {
            const img = new Image();
            img.onload = function() {
              stampSourceImage = img;
              const fitInfo = Math.min(1, 30 / img.width, 30 / img.height);
              const baseW = Math.floor(img.width * fitInfo);
              const baseH = Math.floor(img.height * fitInfo);
              stampBaseSize = { w: baseW, h: baseH };
              stampScale = 1.0; 
              stampMode = "image";
              refreshStampBuffer();
              document.getElementById("stamp-hint").classList.remove("hidden");
              canvas.style.cursor = "none";
            };
            img.src = e.target.result;
         }
         reader.readAsDataURL(file);
      }
      
      // Drag & Drop Global Highlight
      let dragCounter = 0;
      const uploadBtn = document.getElementById('upload-btn');

      document.body.addEventListener('dragenter', (e) => {
         e.preventDefault(); 
         e.stopPropagation();
         dragCounter++;
         // Highlight button
         if(uploadBtn) {
            uploadBtn.classList.remove('bg-gray-700', 'border-gray-600');
            uploadBtn.classList.add('bg-blue-600', 'border-blue-400', 'ring-2', 'ring-blue-400', 'ring-opacity-50', 'scale-105');
         }
      });
      
      document.body.addEventListener('dragleave', (e) => {
         e.preventDefault(); 
         e.stopPropagation();
         dragCounter--;
         if (dragCounter === 0 && uploadBtn) {
            uploadBtn.classList.add('bg-gray-700', 'border-gray-600');
            uploadBtn.classList.remove('bg-blue-600', 'border-blue-400', 'ring-2', 'ring-blue-400', 'ring-opacity-50', 'scale-105');
         }
      });
      
      document.body.addEventListener('dragover', (e) => {
         e.preventDefault(); 
         e.stopPropagation();
      });
      
      document.body.addEventListener('drop', (e) => {
         e.preventDefault();
         e.stopPropagation();
         dragCounter = 0;
         if(uploadBtn) {
            uploadBtn.classList.add('bg-gray-700', 'border-gray-600');
            uploadBtn.classList.remove('bg-blue-600', 'border-blue-400', 'ring-2', 'ring-blue-400', 'ring-opacity-50', 'scale-105');
         }
         
         if(e.dataTransfer.files && e.dataTransfer.files[0]) {
            const file = e.dataTransfer.files[0];
            if(file.type.startsWith('image/')) {
               processImageFile(file);
            }
         }
      });
      
      // Help
      function toggleHelp() {
         const modal = document.getElementById('help-modal');
         modal.classList.toggle('hidden');
      }

      function generateDrawBlueprint() {
        const entities = [];
        let entityId = 1;
        const autoPole = document.getElementById('auto-pole-toggle').checked;
        const poleType = document.getElementById('pole-type-select').value;
        const qualityIdx = parseInt(document.getElementById('pole-quality-select').value);
        
        const data = POLE_DATA[poleType];
        
        // 1. Calculate Bounding Box
        let minX = GRID_W, minY = GRID_H, maxX = -1, maxY = -1;
        let hasPixels = false;

        for (let y = 0; y < GRID_H; y++) {
          for (let x = 0; x < GRID_W; x++) {
            if (gridData[y][x]) {
               hasPixels = true;
               if (x < minX) minX = x;
               if (x > maxX) maxX = x;
               if (y < minY) minY = y;
               if (y > maxY) maxY = y;
            }
          }
        }

        if (!hasPixels) {
          alert("Canvas is empty!");
          return;
        }

        const poles = [];
        if (autoPole) {
           const activePoles = calculateActivePoles(poleType, qualityIdx, minX, minY, maxX, maxY);
           
           // --- MST Wiring Logic (Kruskal's) ---
           // 1. Generate all valid edges
           const edges = [];
           const reach = data.wire[qualityIdx];
           // Optimize: N^2 might be slow for large N, but usually poles < 1000.
           // Limit check to reasonable proximity? 
           // For now, simple N^2 check on activePoles is robust.
           for(let i=0; i<activePoles.length; i++) {
              for(let j=i+1; j<activePoles.length; j++) {
                  const p1 = activePoles[i];
                  const p2 = activePoles[j];
                  const d2 = Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2);
                  if (d2 <= reach * reach) {
                      edges.push({ u: i, v: j, dist: d2 });
                  }
              }
           }
           
           // 2. Sort by distance
           edges.sort((a, b) => a.dist - b.dist);
           
           // 3. Union-Find to build MST
           const parent = new Array(activePoles.length).fill(0).map((_, i) => i);
           const find = (i) => {
               if (parent[i] !== i) parent[i] = find(parent[i]);
               return parent[i];
           };
           const union = (i, j) => {
               const rootI = find(i);
               const rootJ = find(j);
               if (rootI !== rootJ) {
                   parent[rootI] = rootJ;
                   return true;
               }
               return false;
           };
           
           // Initialize adjacency for export
           activePoles.forEach(p => p.neighbours = []);
           
           // Build Tree
           edges.forEach(edge => {
               if (union(edge.u, edge.v)) {
                   // Add connection
                   activePoles[edge.u].neighbours.push(edge.v);
                   activePoles[edge.v].neighbours.push(edge.u);
               }
           });
           // ------------------------------------

           activePoles.forEach((p, idx) => {
               // Assign entity IDs here to ensure we know them for neighbours
               p.entity_number = entityId++;
           });

           activePoles.forEach((p, idx) => {
               // Map neighbor indices to entity numbers
               const neighbourIds = p.neighbours.map(nIdx => activePoles[nIdx].entity_number);
               
               const entity = {
                  entity_number: p.entity_number,
                  name: poleType,
                  position: { x: p.x - minX, y: p.y - minY },
                  neighbours: neighbourIds
               };
               
               if (qualityIdx > 0) {
                   entity.quality = QUALITY_NAMES[qualityIdx];
               }
               
               entities.push(entity);
               poles.push(p);
           });
        }
        
        // Helper to check collision with generated poles
        const isPole = (x, y) => {
           if (!autoPole) return false;
           return poles.some(p => {
               return x >= p.x && x < p.x + data.size && y >= p.y && y < p.y + data.size;
           });
        };

        // Generate Lamps (skipping poles)
        for (let y = minY; y <= maxY; y++) {
          for (let x = minX; x <= maxX; x++) {
            const hex = gridData[y][x];
            if (hex) {
               if (isPole(x, y)) continue;

              const rgb = hexToRgb(hex);
              entities.push({
                entity_number: entityId++,
                name: "small-lamp",
                position: { x: x - minX, y: y - minY },
                color: { r: rgb.r / 255, g: rgb.g / 255, b: rgb.b / 255, a: 1 },
                always_on: true,
              });
            }
          }
        }

        const bp = {
          blueprint: {
            item: "blueprint",
            label: "Factorio Art",
            entities: entities,
            icons: [{ signal: { type: "item", name: "small-lamp" }, index: 1 }],
            version: 562949958139904,
          },
        };

        const area = document.getElementById("clipboard-target");
        area.value = encodeBlueprint(bp);
        area.select();
        area.select();
        document.execCommand("copy");
        area.blur(); // Fix focus stealing preventing hotkeys
        document.body.focus();

        const statusEl = document.getElementById("canvas-status");
        statusEl.textContent = "Blueprint Copied!";
        statusEl.className = "text-green-400 font-bold";
        setTimeout(() => {
          statusEl.textContent = "READY";
          statusEl.className = "font-bold opacity-70";
        }, 3000);
      }
      
      // Need to keep FloodFill, Stamp Generators, Export...
      // FloodFill needs large stack optimization?
      // 2000x2000 flood fill might be deep. 4M pixels.
      // Iterative implementation is already used.
      
      initDraw(); // Initialize and Render 
      
      // --- Custom Quality UI Logic ---
      function initQualityUI() {
          const menu = document.getElementById("quality-dropdown-menu");
          if(!menu) return;
          
          QUALITY_NAMES.forEach((name, idx) => {
              const btn = document.createElement("button");
              btn.className = "flex items-center gap-3 px-3 py-2 hover:bg-gray-800 text-left transition-colors w-full border-b border-gray-800 last:border-0";
              btn.onclick = (e) => {
                  e.stopPropagation();
                  selectQuality(idx);
              };
              
              btn.innerHTML = `
                  <img src="${QUALITY_IMAGES[idx]}" class="w-5 h-5 object-contain">
                  <span class="text-xs font-bold capitalize ${idx === 0 ? 'text-gray-300' : ''}" style="${idx > 0 ? 'color:' + QUALITY_COLORS[idx] : ''}">
                    ${name}
                  </span>
              `;
              menu.appendChild(btn);
          });
          
          // Select default
          selectQuality(0);
          
          // Click outside helper
          window.addEventListener('click', (e) => {
              const menu = document.getElementById("quality-dropdown-menu");
              const btn = document.querySelector("button[onclick='toggleQualityDropdown()']");
              if (menu && !menu.classList.contains("hidden")) {
                   if (!menu.contains(e.target) && !btn.contains(e.target)) {
                       menu.classList.add("hidden");
                   }
              }
          });
      }
      
      function toggleQualityDropdown() {
          const menu = document.getElementById("quality-dropdown-menu");
          menu.classList.toggle("hidden");
      }
      
      function selectQuality(idx) {
          document.getElementById("pole-quality-select").value = idx;
          
          const display = document.getElementById("quality-display");
          display.innerHTML = `
              <img src="${QUALITY_IMAGES[idx]}" class="w-5 h-5 object-contain">
              <span class="capitalize" style="color: ${QUALITY_COLORS[idx] === '#9ca3af' ? '#e5e7eb' : QUALITY_COLORS[idx]}">${QUALITY_NAMES[idx]}</span>
          `;
          
          document.getElementById("quality-dropdown-menu").classList.add("hidden");
          requestAnimationFrame(renderCanvas);
      }
      
      initQualityUI();
    </script>
  </body>
</html>
